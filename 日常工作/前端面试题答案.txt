1.函数声明和函数表达式的区别？
函数声明 function a( ){ }
函数表达式 var a = function( ){ }
函数声明有提升，可以在任意位置调用，函数表达式没有提升，要先定义在调用。
2.闭包？
有权访问一个函数的局部变量的函数，就叫闭包。闭包是沟通函数外和函数内的桥梁，闭包可以获取函数内部的变量，可以将数据一直保存在内存，利用闭包可以实现set get方法，避免受其他作用域影响。
改变函数this指向？
.call(新this指向,参数，参数)；
.apply(新this指向，[参数，参数])；
.bind(text);
可以根据参数格式决定用哪种方式。
call和apply 会只执行，bind 不会

3.阻止事件冒泡？
event.stopPropagation();
event.cancelBubble = true;

4.取消默认事件？
event.preventDefault();
event.returnValue = false;

5.深拷贝浅拷贝？
浅拷贝是拷贝的指针地址
深拷贝是拷贝的值
JSON.parse(JSON.stringify( ));
递归遍历
如果是一层，可以用Object.assign({},object);
[...a]

6.数组去重？
indexof()去重，创建一个新数组[ ],对原数组进行遍历用indexof()判断在新数组中是否存在，-1为不存在，进行push到新数组中。
相邻元素去重，先调用sort()排序；然后比较相邻元素，不相等的push到新数组中
对象属性去重，遍历数组将对象的值设为对象的属性，对象无arr[i],则push到数组中，在obj上添加arr[i]赋初值1,如果有则将值++
.includes();
set与结构赋值去重   [...new Set（[1,2,3,2])；]

7.vue生命周期？
beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
beforeDestroy
destroyed
Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载dom、渲染 更新 渲染、销毁等一系列过程，我们称这为Vue的生命周期。通俗的讲就是Vue实例从创建到销毁的过程就是生命周期。
每个组件或实例都会经历一个完成的生命周期，总共分为三个阶段：初始化、运行中、销毁。
实例或组件通过new Vue（）创建出来之后初始化事件和生命周期，然后就会执行beforeCreate钩子函数，此时数据还没有挂载，无法访问数据和真实的dom。
挂载数据，绑定事件等等，然后执行created函数，此时可以使用数据和修改数据，此处更改数据不会触发updated函数，一般在这里做初始化数据的获取。
接下来开始找实例或组件对应的模板，看看有没有el属性，再看看有没有模板属性，如果有模板属性就把模板属性传染出去，如果没有就把el上的东西当做模板，编译模板为虚拟dom放入到render函数中准备渲染，执行beforeMount函数，在这个函数中虚拟dom已经创建完成，马上可以渲染。
开始render,渲染出真实dom，然后执行mounted函数，此时组件已经出现在页面中，数据和真是dom都已经处理好了，事件都已经挂载好了，可以处理真实的dom了
当组件或实例的数据更改之后，会立即执行beforeUpdate,然后vue的虚拟dom机制重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比后重新渲染
更新完成后执行updated,数据已经更改完成，dom也重新render完成，可以操作更新后的dom了
当销毁时，立即执行beforeDestroy,此处一般做善后工作，例如清除计时器等
组件的数据绑定、监听 去掉后执行下dom,此时执行destroy.

8.组件之间怎么传值？
兄弟组件传值：
var EventBus = new Vue();
Object.defineProperties(Vue.prototype,{
$bus:{
get: function(){
   return  EventBus
}
}
})

9.路由跳转？
声明式路由  router-link    :to="{}"
编程式 this.$router.push
path和params不能同时使用
this.$router.replace( )
传参用query 和params


10.路由守卫？
全局前置守卫beforeEach
                    afterEach
                    beforeResolve
路由独享守卫beforeEnter
组件路由守卫 beforeRouterEnter
                    beforeRouterUpdate
                    beforeRouteLeave
导航被触发
在失活的组件里调用离开守卫
调用全局的beforeEach守卫
在重用的组件里调用beforeUpdate守卫
在路由配置中调用路由独享守卫beforeEnter
解析异步路由组件
在被激活的组件里调用beforeRouteEnter
调用全局的路由解析守卫beforeResolve守卫
导航被确认
调用全局的后置钩子afterEach
触发dom更新
用创建好的实例调用beforeRouterEnter守卫中传给next的回调函数


11.页面缓存？
keep-alive


12.为什么用vuex？
多视图依赖同一个状态，对于多层嵌套的组件非常繁琐，兄弟组件状态传递无能为力
来自不同视图的行为变更同一状态，采用父子组件直接引用或者通过事件来变更和同步状态
这些模式会导致代码无法维护，所以把共享状态抽取出来。


13.vuex包含哪些属性？
state      在计算属性中读取 return this.$store.state.count
getters    
mutations       this.$store.commit(state,{ });  同步函数
actions          this.$store.dispatch("   ",{  });  异步函数
modules


14.v-show  v-if的区别？
v-show是display:none
v-if是移除节点 添加节点
操作频繁可以用v-show

15.v-for  v-if的优先级？
v-for优先级高

16.生命周期函数可以用箭头函数嘛？
不可以，箭头函数中是没有this的


17.如何提高页面加载速度？
路由懒加载，组件懒加载
开启gzip
去掉.map文件
引用cdn
图片压缩


18.vue更新视图的方法？
this.$set(obj,key,value)


19.jq事件监听的方法？
.bind(types, data,fn)
.live(types,data,fn)   绑定到document
.delegate('li','click',data,fn)   绑定到父元素
.on('click','li'data,fn)

jq事件委托？
将监听函数绑定在父节点上，让父辈完成事件监听，这样就把事情“委托”过去了。在父辈元素的监听函数中，可以通过event.target属性那带触发的原始元素，然后再对其进行相关处理。


jq修改样式的方法？
.css({"width":"30px"});
.style.width = "30px";
.addClass();


jq有哪些选择器？
es6中哪些用法？
let const
结构赋值
new set()
promise
async   await
Array.from() 将类对象转换为数组
Array.of(1，2，3)     将一组值转换为数组 [1,2,3];
Object.keys();
Object.assign()
函数默认值

作用域链？
作用域分为全局作用域和局部作用域；
在当前作用域中没有找到值，就会向上级作用域去查，直到查到全局作用域，这个查找过程就形成链条，叫做作用域链


prototype、__proto__与constructor？
__proto__ 和constructor属性是对象独有的。
prototype属性是函数独有的。但是js中函数也是一种对象，所以函数也拥有__proto__和constructor属性

__proto__ ：
__proto__ 的作用是当访问一个对象属性时，如果该对象内部不存在这个属性，那么就会去他的__proto__属性所指向的对象中寻找，如果父对象也不存在这个属性，就继续向上查找，直到原型链顶端null,由以上这种通过__proto__属性来链接对象直到null的一条链即为原型链。
平时调用定的字符串方法、数组方法、对象方法、函数方法都是靠__proto__继承来的。

prototype：
是函数独有的，它是从一个函数指向一个对象，它的含义是函数的原型对象，也就是这个函数




less 如何定义变量？
@
用过哪些前端框架？
iview
elementUI  
antd
layui

如何判断一个变量的类型?
typeof


开发过小程序吗？




Event Loop是什么？
事件循环机制，解决javascript单线程运行时不会阻塞的一种机制，就是异步原理
是执行模型，在不同的地方有不同的实现。浏览器和Node.js基于不同的技术实现了各自的Event Loop。
node.js 是根据libuv，浏览器的eventLoop是在html5的规范中明确定义

同步、异步又分宏任务和微任务
宏任务Tasks包括：
setTimeout
setInterval
setImmediate(Node独有)
requestAnimationFrame(浏览器有)
I/O
Ul rendering (浏览器独有)

微任务Microtasks包括：
process.nextTick(Node独有)
Promise.then()
Object.observe
MutationObserve
注意：Promise构造函数中的代码是同步执行的


Tasks 宏任务队列
Microtasks 微任务队列
JS stack js调用栈
Log控制台

从事件队列取一个事件时，有微任务就把微任务执行完，然后才开始执行事件
在浏览器端所有的宏任务都在一个队列里边执行，微任务会追加到当前一轮事件循环的末尾


node.js中 process.nextTick 优先于 .then

总结：
浏览器的Event Loop和Node.js的EventLoop是不同的，实现机制也是不同的，不能混为一谈。
Node.js可以理解为有4个宏任务队列和2个微任务队列，但是执行宏任务时有6个阶段。
Node.js中，先执行全局Script代码，执行完同步代码调用栈清空后，先从微任务队列Next Tick Queue中一次取出
所有的任务放入调用栈中执行，再从微任务队列other microtask Queue中依次取出所有的任务放入调用栈中执行。
然后开始宏任务的6个阶段，每个阶段都将该宏任务队列中的所有任务都取出来执行（注意，这里和浏览器不一样，浏览器只取一个），每个宏任务执行完毕后，考试执行微任务，再开始执行下一阶段宏任务，以此构成事件循环。

Node端的EventLoop
times计时器 setTimeout  setInterval的回调
I/O
idle,prepare  node内部用
poll轮询
check检查 存放setImmediate回调
close callbacks 关闭的回调如：sockect.on("close")


浏览器渲染优化
performance 工具
浏览器1s刷新频率60Hz  75Hz
卡死 fps = 1
卡顿1<fps<60

javascript  style  layout   paint   composite
js/css   样式   布局  绘制   合成


setTimeout  和 requestAnimationFrame





1.javascript核心
对象、原型链、构造函数、执行上下文堆栈、执行上下文、变量对象、活动对象、作用域链、闭包、this
2.运行时的描述
对于每个执行上下文，都有三个重要的属性：
变量对象
作用域链
this

三种类型的代码：全局代码、函数代码和eval代码


函数提升优先于变量提升
填充VO的顺序是：函数的形参 > 函数声明 > 变量声明


如何解决跨域？
后端配置cors
proxy
jsonp




























